Index: src/com/chess/engine/pieces/Pawn.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.chess.engine.pieces;\n\nimport com.chess.engine.Alliance;\nimport com.chess.engine.board.Board;\nimport com.chess.engine.board.BoardUtils;\nimport com.chess.engine.board.Move;\nimport com.chess.engine.board.Move.*;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Pawn extends Piece {\n\n    /**\n     * The possible move offsets for a pawn\n     * 8: up\n     * 7: up and right\n     * 9: up and left\n     */\n    private final static int[] CANDIDATE_MOVE_COORDINATE = {8, 16, 7, 9};\n\n    /**\n     * Constructor\n     *\n     * @param piecePosition the position of the piece\n     * @param pieceAlliance the alliance of the piece\n     */\n    public Pawn(final int piecePosition, final Alliance pieceAlliance) {\n        super(PieceType.PAWN, piecePosition, pieceAlliance, true);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param piecePosition the position of the piece\n     * @param pieceAlliance the alliance of the piece\n     * @param isFirstMove   if the piece has moved\n     */\n    public Pawn(final int piecePosition, final Alliance pieceAlliance, final boolean isFirstMove) {\n        super(PieceType.PAWN, piecePosition, pieceAlliance, isFirstMove);\n    }\n\n    /**\n     * Print the piece\n     *\n     * @return the piece as a string\n     */\n    @Override\n    public String toString() {\n        return PieceType.PAWN.toString();\n    }\n\n    /**\n     * Calculate the legal moves for the Pawn\n     *\n     * @param board the board\n     * @return a collection of legal moves\n     */\n    @Override\n    public Collection<Move> calculateLegalMoves(final Board board) {\n\n        final List<Move> legalMoves = new ArrayList<>(); /* for each of the possible moves, check if the move is legal */\n\n        for (final int currentCandidateOffset : CANDIDATE_MOVE_COORDINATE) { /* for each of the possible moves*/\n            /* add the offset to the current position to get the destination coordinate */\n            final int candidateDestinationCoordinate = this.piecePosition +\n                    (this.getPieceAlliance().getDirection() * currentCandidateOffset);\n\n            // One move forward\n            if (!BoardUtils.isValidTileCoordinate(candidateDestinationCoordinate)) {\n                continue; /* if the tile is not occupied, continue checking*/\n            }\n\n            /* if you are moving one tile forward and the tile is not occupied*/\n            if (currentCandidateOffset == 8 && !board.getTile(candidateDestinationCoordinate).isTileOccupied()) {\n                if (this.pieceAlliance.isPawnPromotionSquare(candidateDestinationCoordinate)) {\n                    legalMoves.add(new PawnPromotion(\n                            new PawnMove(board, this, candidateDestinationCoordinate)));\n                } else {\n                    legalMoves.add(new PawnMove(board, this, candidateDestinationCoordinate));\n                }\n            }\n            // Two moves forward\n            else if (currentCandidateOffset == 16 && this.isFirstMove &&                                 /* if you are moving two tiles forward, and it is the first move AND */\n                    ((BoardUtils.SECOND_ROW[this.piecePosition] && this.getPieceAlliance().isBlack()) || /* if you are on the second row and your alliance is black or */\n                            (BoardUtils.SEVENTH_ROW[this.piecePosition] && this.getPieceAlliance().isWhite()))) { /* if you are on the seventh row and your alliance is white */\n                /* between the current position and the destination position, there must be an empty tile */\n                final int behindCandidateDestinationCoordinate = this.piecePosition + (this.pieceAlliance.getDirection() * 8);\n\n                if (!board.getTile(behindCandidateDestinationCoordinate).isTileOccupied() &&                /* if the tile behind the destination is not occupied and */\n                        !board.getTile(candidateDestinationCoordinate).isTileOccupied()) {                 /* if the destination tile is not occupied */\n                    legalMoves.add(new PawnJump(board, this, candidateDestinationCoordinate)); /* add the move to the list of legal moves */\n                }\n            }\n            // Attack move to the left\n            else if (currentCandidateOffset == 9 &&                                                          /* if you are moving one tile diagonally to the right */\n                    !((BoardUtils.FIRST_COLUMN[this.piecePosition] && this.pieceAlliance.isWhite() ||       /* and you are not on the first column, and you are white */\n                            (BoardUtils.EIGHTH_COLUMN[this.piecePosition] && this.pieceAlliance.isBlack())))) {       /* or you are not on the eighth column, and you are black  (because of promotions)*/\n\n                /* if there exist an en passant pawn, and its position is to the left of the current position */\n                if (board.getEnPassantPawn() != null && board.getEnPassantPawn().getPiecePosition() ==\n                        (this.piecePosition - (this.pieceAlliance.getOppositeDirection()))) {\n                    final Piece pieceOnCandidate = board.getEnPassantPawn();\n                    /* if the candidate piece is not the same alliance as the current piece add the move to the legals */\n                    if (this.pieceAlliance != pieceOnCandidate.getPieceAlliance()) {\n                        legalMoves.add( /* add the move to the list of legal moves */\n                                new PawnEnPassantAttackMove(board, this,\n                                        candidateDestinationCoordinate, pieceOnCandidate));\n                    }\n                }\n                /* if the tile is occupied*/\n                else if (board.getTile(candidateDestinationCoordinate).isTileOccupied()) {\n                    /* get the piece on the tile */\n                    final Piece pieceAtDestination = board.getTile(candidateDestinationCoordinate).getPiece();\n                    /* if the piece is not the same color as the pawn*/\n                    if (this.pieceAlliance != pieceAtDestination.getPieceAlliance()) {\n                        if (this.pieceAlliance.isPawnPromotionSquare(candidateDestinationCoordinate)) {\n                            legalMoves.add(new PawnPromotion(new PawnAttackMove(board, this,\n                                    candidateDestinationCoordinate, pieceAtDestination)));\n                        } else {\n                            legalMoves.add(new PawnAttackMove(board, this,\n                                    candidateDestinationCoordinate, pieceAtDestination));\n                        }\n                    }\n                }\n            }\n            // Attack move to the right\n            else if (currentCandidateOffset == 7 &&                                                          /* if you are moving one tile diagonally to the left */\n                    !((BoardUtils.FIRST_COLUMN[this.piecePosition] && this.pieceAlliance.isBlack() ||       /* and you are not on the first column, and you are black */\n                            (BoardUtils.EIGHTH_COLUMN[this.piecePosition] && this.pieceAlliance.isWhite())))) {       /* or you are not on the eighth column, and you are white  (because of promotions)*/\n\n                /* if there exist an en passant pawn, and its position is to the right of the current position */\n                if (board.getEnPassantPawn() != null && board.getEnPassantPawn().getPiecePosition() ==\n                        (this.piecePosition + (this.pieceAlliance.getOppositeDirection()))) {\n                    final Piece pieceOnCandidate = board.getEnPassantPawn();\n                    /* if the candidate piece is not the same alliance as the current piece add the move to the legals */\n                    if (this.pieceAlliance != pieceOnCandidate.getPieceAlliance()) {\n                        legalMoves.add(\n                                new PawnEnPassantAttackMove(board, this,\n                                        candidateDestinationCoordinate, pieceOnCandidate));\n                    }\n                }\n                /* if the tile is occupied*/\n                else if (board.getTile(candidateDestinationCoordinate).isTileOccupied()) {\n                    /* get the piece on the tile */\n                    final Piece pieceAtDestination = board.getTile(candidateDestinationCoordinate).getPiece();\n                    /* if the piece is not the same color as the pawn*/\n                    if (this.pieceAlliance != pieceAtDestination.getPieceAlliance()) {\n                        if (this.pieceAlliance.isPawnPromotionSquare(candidateDestinationCoordinate)) {\n                            legalMoves.add(new PawnPromotion(new PawnAttackMove(board, this,\n                                    candidateDestinationCoordinate, pieceAtDestination)));\n                        } else {\n                            legalMoves.add(new PawnAttackMove(board, this,\n                                    candidateDestinationCoordinate, pieceAtDestination));\n                        }\n                    }\n                }\n            }\n        }\n\n\n    return Collections.unmodifiableList(legalMoves); /* return an unmodifiable list of legal moves */\n    }\n\n    /**\n     * Return a new piece with the updated position\n     *\n     * @param move the move\n     * @return a new piece with the updated position\n     */\n    @Override\n    public Piece movePiece (Move move){\n        return new Pawn(move.getDestinationCoordinate(), move.getMovedPiece().getPieceAlliance());\n    }\n\n    public Piece getPromotionPiece() {\n        return new Queen(this.piecePosition, this.pieceAlliance, false);\n    }\n}\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/com/chess/engine/pieces/Pawn.java b/src/com/chess/engine/pieces/Pawn.java
--- a/src/com/chess/engine/pieces/Pawn.java	(revision e650c178dc83369531ea90243b6ddcf7703dc278)
+++ b/src/com/chess/engine/pieces/Pawn.java	(date 1669108264543)
@@ -84,7 +84,7 @@
             }
             // Two moves forward
             else if (currentCandidateOffset == 16 && this.isFirstMove &&                                 /* if you are moving two tiles forward, and it is the first move AND */
-                    ((BoardUtils.SECOND_ROW[this.piecePosition] && this.getPieceAlliance().isBlack()) || /* if you are on the second row and your alliance is black or */
+                    ((BoardUtils.SECOND_ROW[this.piecePosition] && this.getPieceAlliance().isBlack()) || /* if you are on the second row and your alliance is black OR */
                             (BoardUtils.SEVENTH_ROW[this.piecePosition] && this.getPieceAlliance().isWhite()))) { /* if you are on the seventh row and your alliance is white */
                 /* between the current position and the destination position, there must be an empty tile */
                 final int behindCandidateDestinationCoordinate = this.piecePosition + (this.pieceAlliance.getDirection() * 8);
